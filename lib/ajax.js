// Generated by CoffeeScript 2.3.1
(function() {
  var $, Ajax, Base, Collection, Extend, GenerateURL, Include, Model, Queue, Singleton, Spine,
    boundMethodCheck = function(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new Error('Bound instance method accessed before binding'); } };

  Spine = this.Spine || require('spine');

  $ = Spine.$;

  Model = Spine.Model;

  Queue = $({});

  Ajax = {
    getURL: function(object) {
      if (object.className != null) {
        return this.generateURL(object);
      } else {
        return this.generateURL(object, encodeURIComponent(object.id));
      }
    },
    getCollectionURL: function(object) {
      return this.generateURL(object);
    },
    getScope: function(object) {
      return (typeof object.scope === "function" ? object.scope() : void 0) || object.scope;
    },
    getCollection: function(object) {
      if (object.url !== object.generateURL) {
        if (typeof object.url === 'function') {
          return object.url();
        } else {
          return object.url;
        }
      } else if (object.className != null) {
        return object.className.toLowerCase() + 's';
      }
    },
    generateURL: function(object, ...args) {
      var collection, path, scope;
      collection = Ajax.getCollection(object) || Ajax.getCollection(object.constructor);
      scope = Ajax.getScope(object) || Ajax.getScope(object.constructor);
      args.unshift(collection);
      args.unshift(scope);
      // construct and clean url
      path = args.join('/');
      path = path.replace(/(\/\/)/g, "/");
      path = path.replace(/^\/|\/$/g, "");
      // handle relative urls vs those that use a host
      if (path.indexOf("../") !== 0) {
        return Model.host + "/" + path;
      } else {
        return path;
      }
    },
    enabled: true,
    disable: function(callback) {
      var e;
      if (this.enabled) {
        this.enabled = false;
        try {
          return callback();
        } catch (error1) {
          e = error1;
          throw e;
        } finally {
          this.enabled = true;
        }
      } else {
        return callback();
      }
    },
    queue: function(request) {
      if (request) {
        return Queue.queue(request);
      } else {
        return Queue.queue();
      }
    },
    clearQueue: function() {
      return this.queue([]);
    },
    config: {
      loadMethod: 'GET',
      updateMethod: 'PUT',
      createMethod: 'POST',
      destroyMethod: 'DELETE'
    }
  };

  Base = (function() {
    class Base {
      ajax(params, defaults) {
        return $.ajax(this.ajaxSettings(params, defaults));
      }

      ajaxQueue(params, defaults, record) {
        var deferred, jqXHR, parallel, promise, request, settings;
        jqXHR = null;
        deferred = $.Deferred();
        promise = deferred.promise();
        if (!Ajax.enabled) {
          return promise;
        }
        settings = this.ajaxSettings(params, defaults);
        // prefer setting if exists else default is to parallelize 'GET' requests
        parallel = settings.parallel !== void 0 ? settings.parallel : settings.type === 'GET';
        request = function(next) {
          var ref, reject, resolve;
          if ((record != null ? record.id : void 0) != null) {
            // for existing singleton, model id may have been updated
            // after request has been queued
            if (settings.url == null) {
              settings.url = Ajax.getURL(record);
            }
            if ((ref = settings.data) != null) {
              ref.id = record.id;
            }
          }
          // 2 reasons not to stringify: if already a string, or if intend to have ajax processData
          if (typeof settings.data !== 'string' && settings.processData !== true) {
            settings.data = JSON.stringify(settings.data);
          }
          // enable promise callbacks to access the request's settings object
          resolve = function() {
            return deferred.resolve.apply(this, [...arguments, settings]);
          };
          reject = function() {
            return deferred.reject.apply(this, [...arguments, settings]);
          };
          jqXHR = $.ajax(settings);
          jqXHR.done(resolve);
          jqXHR.fail(reject);
          jqXHR.then(next, next);
          if (parallel) {
            return Queue.dequeue();
          }
        };
        promise.abort = function(statusText) {
          var index;
          if (jqXHR) {
            return jqXHR.abort(statusText);
          }
          index = $.inArray(request, this.queue());
          if (index > -1) {
            this.queue().splice(index, 1);
          }
          deferred.rejectWith(settings.context || settings, [promise, statusText, '']);
          return promise;
        };
        this.queue(request);
        return promise;
      }

      ajaxSettings(params, defaults) {
        return $.extend({}, this.defaults, defaults, params);
      }

    };

    Base.prototype.defaults = {
      dataType: 'json',
      processData: false,
      headers: {
        'X-Requested-With': 'XMLHttpRequest'
      }
    };

    Base.prototype.queue = Ajax.queue;

    return Base;

  }).call(this);

  Collection = class Collection extends Base {
    constructor(model) {
      super();
      // Private
      this.recordsResponse = this.recordsResponse.bind(this);
      this.failResponse = this.failResponse.bind(this);
      this.model = model;
    }

    find(id, params, options = {}) {
      var record;
      record = new this.model({
        id: id
      });
      return this.ajaxQueue(params, {
        type: options.method || Ajax.config.loadMethod,
        url: options.url || Ajax.getURL(record),
        parallel: options.parallel
      }).done(this.recordsResponse(options)).fail(this.failResponse(options));
    }

    all(params, options = {}) {
      return this.ajaxQueue(params, {
        type: options.method || Ajax.config.loadMethod,
        url: options.url || Ajax.getURL(this.model),
        parallel: options.parallel
      }).done(this.recordsResponse(options)).fail(this.failResponse(options));
    }

    fetch(params = {}, options = {}) {
      var id;
      if (id = params.id) {
        delete params.id;
        return this.find(id, params, options).done((record) => {
          return this.model.refresh(record, options);
        });
      } else {
        return this.all(params, options).done((records) => {
          return this.model.refresh(records, options);
        });
      }
    }

    recordsResponse(options) {
      boundMethodCheck(this, Collection);
      return (data, status, xhr, settings) => {
        var ref;
        this.model.trigger('ajaxSuccess', null, status, xhr, settings);
        return (ref = options.done) != null ? ref.call(this.model, settings) : void 0;
      };
    }

    failResponse(options) {
      boundMethodCheck(this, Collection);
      return (xhr, statusText, error, settings) => {
        var ref;
        this.model.trigger('ajaxError', null, xhr, statusText, error, settings);
        return (ref = options.fail) != null ? ref.call(this.model, settings) : void 0;
      };
    }

  };

  Singleton = class Singleton extends Base {
    constructor(record1) {
      super();
      // Private
      this.recordResponse = this.recordResponse.bind(this);
      this.failResponse = this.failResponse.bind(this);
      this.record = record1;
      this.model = this.record.constructor;
    }

    reload(params, options = {}) {
      return this.ajaxQueue(params, {
        type: options.method || Ajax.config.loadMethod,
        url: options.url,
        parallel: options.parallel
      }, this.record).done(this.recordResponse(options)).fail(this.failResponse(options));
    }

    create(params, options = {}) {
      return this.ajaxQueue(params, {
        type: options.method || Ajax.config.createMethod,
        contentType: 'application/json',
        data: this.record.toJSON(),
        url: options.url || Ajax.getCollectionURL(this.record),
        parallel: options.parallel
      }).done(this.recordResponse(options)).fail(this.failResponse(options));
    }

    update(params, options = {}) {
      return this.ajaxQueue(params, {
        type: options.method || Ajax.config.updateMethod,
        contentType: 'application/json',
        data: this.record.toJSON(),
        url: options.url,
        parallel: options.parallel
      }, this.record).done(this.recordResponse(options)).fail(this.failResponse(options));
    }

    destroy(params, options = {}) {
      return this.ajaxQueue(params, {
        type: options.method || Ajax.config.destroyMethod,
        url: options.url,
        parallel: options.parallel
      }, this.record).done(this.recordResponse(options)).fail(this.failResponse(options));
    }

    recordResponse(options) {
      boundMethodCheck(this, Singleton);
      return (data, status, xhr, settings) => {
        var ref;
        if ((data != null) && Object.getOwnPropertyNames(data).length && !this.record.destroyed) {
          this.record.refresh(data, {
            ajax: false
          });
        }
        this.record.trigger('ajaxSuccess', this.record, this.model.fromJSON(data), status, xhr, settings);
        return (ref = options.done) != null ? ref.call(this.record, settings) : void 0;
      };
    }

    failResponse(options) {
      boundMethodCheck(this, Singleton);
      return (xhr, statusText, error, settings) => {
        var ref;
        switch (settings.type) {
          case 'POST':
            this.createFailed();
            break;
          case 'DELETE':
            this.destroyFailed();
        }
        this.record.trigger('ajaxError', this.record, xhr, statusText, error, settings);
        return (ref = options.fail) != null ? ref.call(this.record, settings) : void 0;
      };
    }

    createFailed() {
      return this.record.remove({
        clear: true
      });
    }

    destroyFailed() {
      this.record.destroyed = false;
      return this.record.constructor.refresh(this.record);
    }

  };

  // Ajax endpoint
  Model.host = '';

  GenerateURL = {
    include: function(...args) {
      args.unshift(encodeURIComponent(this.id));
      return Ajax.generateURL(this, ...args);
    },
    extend: function(...args) {
      return Ajax.generateURL(this, ...args);
    }
  };

  Include = {
    ajax: function() {
      return new Singleton(this);
    },
    generateURL: GenerateURL.include,
    url: GenerateURL.include
  };

  Extend = {
    ajax: function() {
      return new Collection(this);
    },
    generateURL: GenerateURL.extend,
    url: GenerateURL.extend
  };

  Model.Ajax = {
    extended: function() {
      this.fetch(this.ajaxFetch);
      this.change(this.ajaxChange);
      this.extend(Extend);
      return this.include(Include);
    },
    // Private
    ajaxFetch: function() {
      return this.ajax().fetch(...arguments);
    },
    ajaxChange: function(record, type, options = {}) {
      var base;
      if (options.ajax === false) {
        return;
      }
      return typeof (base = record.ajax())[type] === "function" ? base[type](options.ajax, options) : void 0;
    }
  };

  Model.Ajax.Methods = {
    extended: function() {
      this.extend(Extend);
      return this.include(Include);
    }
  };

  // Globals
  Ajax.defaults = Base.prototype.defaults;

  Ajax.Base = Base;

  Ajax.Singleton = Singleton;

  Ajax.Collection = Collection;

  Spine.Ajax = Ajax;

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Ajax;
  }

}).call(this);

//# sourceMappingURL=ajax.js.map
