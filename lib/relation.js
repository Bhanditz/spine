// Generated by CoffeeScript 2.3.1
(function() {
  var Collection, Instance, Singleton, Spine, association, requireModel, singularize, underscore;

  Spine = this.Spine || require('spine');

  Collection = class Collection extends Spine.Module {
    constructor(options = {}) {
      var key, value;
      super();
      for (key in options) {
        value = options[key];
        this[key] = value;
      }
    }

    all() {
      return this.model.select((rec) => {
        return this.associated(rec);
      });
    }

    first() {
      return this.all()[0];
    }

    last() {
      var values;
      values = this.all();
      return values[values.length - 1];
    }

    count() {
      return this.all().length;
    }

    find(id, notFound = this.model.notFound) {
      var records;
      records = this.select((rec) => {
        return `${rec.id}` === `${id}`;
      });
      return records[0] || (typeof notFound === "function" ? notFound(id) : void 0);
    }

    findAllByAttribute(name, value) {
      return this.model.select((rec) => {
        return this.associated(rec) && rec[name] === value;
      });
    }

    findByAttribute(name, value) {
      return this.findAllByAttribute(name, value)[0];
    }

    select(cb) {
      return this.model.select((rec) => {
        return this.associated(rec) && cb(rec);
      });
    }

    refresh(values) {
      var i, j, k, l, len, len1, len2, match, record, ref, ref1;
      if (values == null) {
        return this;
      }
      ref = this.all();
      for (j = 0, len = ref.length; j < len; j++) {
        record = ref[j];
        delete this.model.irecords[record.id];
        ref1 = this.model.records;
        for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
          match = ref1[i];
          if (!(match.id === record.id)) {
            continue;
          }
          this.model.records.splice(i, 1);
          break;
        }
      }
      if (!Array.isArray(values)) {
        values = [values];
      }
      for (l = 0, len2 = values.length; l < len2; l++) {
        record = values[l];
        record.newRecord = false;
        record[this.fkey] = this.record.id;
      }
      this.model.refresh(values);
      return this;
    }

    create(record, options) {
      record[this.fkey] = this.record.id;
      return this.model.create(record, options);
    }

    add(record, options) {
      return record.updateAttribute(this.fkey, this.record.id, options);
    }

    remove(record, options) {
      return record.updateAttribute(this.fkey, null, options);
    }

    // Private
    associated(record) {
      return record[this.fkey] === this.record.id;
    }

  };

  Instance = class Instance extends Spine.Module {
    constructor(options = {}) {
      var key, value;
      super();
      for (key in options) {
        value = options[key];
        this[key] = value;
      }
    }

    find() {
      return this.model.find(this.record[this.fkey]);
    }

    update(value) {
      if (value == null) {
        return this;
      }
      if (!(value instanceof this.model)) {
        value = new this.model(value);
      }
      if (value.isNew()) {
        value.save();
      }
      this.record[this.fkey] = value && value.id;
      return this;
    }

  };

  Singleton = class Singleton extends Spine.Module {
    constructor(options = {}) {
      var key, value;
      super();
      for (key in options) {
        value = options[key];
        this[key] = value;
      }
    }

    find() {
      return this.record.id && this.model.findByAttribute(this.fkey, this.record.id);
    }

    update(value) {
      if (value == null) {
        return this;
      }
      if (!(value instanceof this.model)) {
        value = this.model.fromJSON(value);
      }
      value[this.fkey] = this.record.id;
      value.save();
      return this;
    }

  };

  singularize = function(str) {
    return str.replace(/s$/, '');
  };

  underscore = function(str) {
    return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/(-|\.)/g, '_').toLowerCase();
  };

  requireModel = function(model) {
    if (typeof model === 'string') {
      return (typeof require === "function" ? require(model) : void 0) || eval(model);
    } else {
      return model;
    }
  };

  association = function(name, model, record, fkey, Ctor) {
    if (typeof model === 'string') {
      model = requireModel(model);
    }
    return new Ctor({
      name: name,
      model: model,
      record: record,
      fkey: fkey
    });
  };

  Spine.Model.extend({
    hasMany: function(name, model, fkey) {
      if (fkey == null) {
        fkey = `${underscore(this.className)}_id`;
      }
      return this.prototype[name] = function(value) {
        return association(name, model, this, fkey, Collection).refresh(value);
      };
    },
    belongsTo: function(name, model, fkey) {
      if (fkey == null) {
        fkey = `${underscore(singularize(name))}_id`;
      }
      this.prototype[name] = function(value) {
        return association(name, model, this, fkey, Instance).update(value).find();
      };
      return this.attributes.push(fkey);
    },
    hasOne: function(name, model, fkey) {
      if (fkey == null) {
        fkey = `${underscore(this.className)}_id`;
      }
      return this.prototype[name] = function(value) {
        return association(name, model, this, fkey, Singleton).update(value).find();
      };
    }
  });

  Spine.Collection = Collection;

  Spine.Singleton = Singleton;

  Spine.Instance = Instance;

}).call(this);

//# sourceMappingURL=relation.js.map
