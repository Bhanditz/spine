// Generated by CoffeeScript 2.3.1
(function() {
  var $, Path, Route, Spine, escapeRegExp, hashStrip, namedParam, splatParam;

  Spine = this.Spine || require('spine');

  $ = Spine.$;

  hashStrip = /^#*/;

  namedParam = /:([\w\d]+)/g;

  splatParam = /\*([\w\d]+)/g;

  escapeRegExp = /[-[\]{}()+?.,\\^$|#\s]/g;

  Path = class Path extends Spine.Module {
    constructor(path, callback) {
      var match;
      super();
      this.names = [];
      this.path = path;
      this.callback = callback;
      if (typeof path === 'string') {
        namedParam.lastIndex = 0;
        while ((match = namedParam.exec(path)) !== null) {
          this.names.push(match[1]);
        }
        splatParam.lastIndex = 0;
        while ((match = splatParam.exec(path)) !== null) {
          this.names.push(match[1]);
        }
        path = path.replace(escapeRegExp, '\\$&').replace(namedParam, '([^\/]*)').replace(splatParam, '(.*?)');
        this.route = new RegExp(`^${path}$`);
      } else {
        this.route = path;
      }
    }

    match(path, options = {}) {
      var i, j, len, match, param, params;
      if (!(match = this.route.exec(path))) {
        return false;
      }
      options.match = match;
      params = match.slice(1);
      if (this.names.length) {
        for (i = j = 0, len = params.length; j < len; i = ++j) {
          param = params[i];
          options[this.names[i]] = param;
        }
      }
      Route.trigger('before', this);
      return this.callback.call(null, options) !== false;
    }

  };

  Route = (function() {
    var ref;

    class Route extends Spine.Module {
      static setup(options = {}) {
        this.options = $.extend({}, this.options, options);
        if (this.options.history) {
          this.history = this.historySupport && this.options.history;
        }
        if (this.options.shim) {
          return;
        }
        if (this.history) {
          $(window).bind('popstate', this.change);
        } else {
          $(window).bind('hashchange', this.change);
        }
        return this.change();
      }

      static unbind() {
        var unbindResult;
        unbindResult = Spine.Events.unbind.apply(this, arguments);
        if (arguments.length > 0) {
          return unbindResult;
        }
        if (this.options.shim) {
          return;
        }
        if (this.history) {
          return $(window).unbind('popstate', this.change);
        } else {
          return $(window).unbind('hashchange', this.change);
        }
      }

      static navigate(...args) {
        var lastArg, options, path, routes;
        options = {};
        lastArg = args[args.length - 1];
        if (typeof lastArg === 'object') {
          options = args.pop();
        } else if (typeof lastArg === 'boolean') {
          options.trigger = args.pop();
        }
        options = $.extend({}, this.options, options);
        path = args.join('/');
        if (this.path === path) {
          return;
        }
        this.path = path;
        if (options.trigger) {
          this.trigger('navigate', this.path);
          routes = this.matchRoutes(this.path, options);
          if (!routes.length) {
            if (typeof options.redirect === 'function') {
              return options.redirect.apply(this, [this.path, options]);
            } else {
              if (options.redirect === true) {
                this.redirect(this.path);
              }
            }
          }
        }
        if (options.shim) {
          return true;
        } else if (this.history && options.replace) {
          return history.replaceState({}, document.title, this.path);
        } else if (this.history) {
          return history.pushState({}, document.title, this.path);
        } else {
          return window.location.hash = this.path;
        }
      }

      static create() {
        var router;
        router = new this;
        this.routers.push(router);
        return router;
      }

      static add(path, callback) {
        //@router ?= new this
        return this.router.add(path, callback);
      }

      add(path, callback) {
        var key, results, value;
        if (typeof path === 'object' && !(path instanceof RegExp)) {
          results = [];
          for (key in path) {
            value = path[key];
            results.push(this.add(key, value));
          }
          return results;
        } else {
          return this.routes.push(new Path(path, callback));
        }
      }

      destroy() {
        var r;
        this.routes.length = 0;
        return this.constructor.routers = (function() {
          var j, len, ref1, results;
          ref1 = this.constructor.routers;
          results = [];
          for (j = 0, len = ref1.length; j < len; j++) {
            r = ref1[j];
            if (r !== this) {
              results.push(r);
            }
          }
          return results;
        }).call(this);
      }

      // Private
      static getPath() {
        var path;
        if (this.history) {
          path = window.location.pathname;
          if (path.substr(0, 1) !== '/') {
            path = '/' + path;
          }
        } else {
          path = window.location.hash;
          path = path.replace(hashStrip, '');
        }
        return path;
      }

      static getHost() {
        return `${window.location.protocol}//${window.location.host}`;
      }

      static change() {
        var path;
        path = Route.getPath();
        if (path === Route.path) {
          return;
        }
        Route.path = path;
        return Route.matchRoutes(Route.path);
      }

      static matchRoutes(path, options) {
        var j, len, match, matches, ref1, router;
        matches = [];
        ref1 = this.routers.concat([this.router]);
        for (j = 0, len = ref1.length; j < len; j++) {
          router = ref1[j];
          match = router.matchRoute(path, options);
          if (match) {
            matches.push(match);
          }
        }
        if (matches.length) {
          this.trigger('change', matches, path);
        }
        return matches;
      }

      static redirect(path) {
        return window.location = path;
      }

      constructor() {
        super();
        this.routes = [];
      }

      matchRoute(path, options) {
        var j, len, ref1, route;
        ref1 = this.routes;
        for (j = 0, len = ref1.length; j < len; j++) {
          route = ref1[j];
          if (route.match(path, options)) {
            return route;
          }
        }
      }

      trigger(...args) {
        args.splice(1, 0, this);
        return this.constructor.trigger(...args);
      }

    };

    Route.extend(Spine.Events);

    Route.historySupport = ((ref = window.history) != null ? ref.pushState : void 0) != null;

    Route.options = {
      trigger: true,
      history: false,
      shim: false,
      replace: false,
      redirect: false
    };

    Route.routers = [];

    return Route;

  }).call(this);

  Route.router = new Route;

  Spine.Controller.include({
    route: function(path, callback) {
      if (this.router instanceof Spine.Route) {
        return this.router.add(path, this.proxy(callback));
      } else {
        return Spine.Route.add(path, this.proxy(callback));
      }
    },
    routes: function(routes) {
      var key, results, value;
      results = [];
      for (key in routes) {
        value = routes[key];
        results.push(this.route(key, value));
      }
      return results;
    },
    navigate: function() {
      return Spine.Route.navigate.apply(Spine.Route, arguments);
    }
  });

  Route.Path = Path;

  Spine.Route = Route;

  if (typeof module !== "undefined" && module !== null) {
    module.exports = Route;
  }

}).call(this);

//# sourceMappingURL=route.js.map
